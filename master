[1mdiff --git a/Makefile~ b/Makefile~[m
[1mdeleted file mode 100644[m
[1mindex 518b394..0000000[m
[1m--- a/Makefile~[m
[1m+++ /dev/null[m
[36m@@ -1,74 +0,0 @@[m
[31m-scan: 		scanMain.o lex.yy.o[m
[31m-		gcc -o scan scanMain.o lex.yy.o[m
[31m-[m
[31m-scanMain.o:	scanMain.c cminus.tab.h[m
[31m-		gcc -c scanMain.c[m
[31m-[m
[31m-[m
[31m-cminus.tab.h:	cminus.y[m
[31m-		bison -d cminus.y[m
[31m-[m
[31m-lex.yy.o:	cminus.l cminus.tab.h[m
[31m-		flex cminus.l[m
[31m-		gcc -c lex.yy.c [m
[31m-[m
[31m-parse:		parseMain.o cminus.tab.o lex.yy.o symtab.o[m
[31m-		gcc -o parse parseMain.o cminus.tab.o symtab.o lex.yy.o[m
[31m-[m
[31m-parseMain.o:	parseMain.c[m
[31m-		gcc -c parseMain.c[m
[31m-[m
[31m-cminus.tab.o:	cminus.y lex.yy.o[m
[31m-		bison cminus.y[m
[31m-		gcc -c cminus.tab.c[m
[31m-[m
[31m-symtab.o:	symtab.c symtab.h[m
[31m-		gcc -c symtab.c[m
[31m-[m
[31m-gencode:	gencodeMain.o gencode.o cminus.tab.o  symtab.o lex.yy.o[m
[31m-		gcc -o gencode gencodeMain.o gencode.o cminus.tab.o  symtab.o lex.yy.o[m
[31m-[m
[31m-gencodeMain.o:	gencodeMain.c  [m
[31m-[m
[31m-[m
[31m-# use del on Windows. use rm on Linux/Cygwin/Mac[m
[31m-clean:		[m
[31m-		rm *.o [m
[31m-[m
[31m-#scan: 		scanMain.o lex.yy.o[m
[31m-#		gcc -o scan scanMain.o lex.yy.o[m
[31m-[m
[31m-#scanMain.o:	scanMain.c tiny.tab.h[m
[31m-#		gcc -c scanMain.c[m
[31m-[m
[31m-#tiny.tab.h:	tiny.y[m
[31m-#		bison -d tiny.y[m
[31m-[m
[31m-#lex.yy.o:	tiny.l tiny.tab.h[m
[31m-#		flex tiny.l[m
[31m-#		gcc -c lex.yy.c [m
[31m-[m
[31m-#parse:		parseMain.o tiny.tab.o  symtab.o lex.yy.o[m
[31m-#		gcc -o parse parseMain.o tiny.tab.o symtab.o lex.yy.o[m
[31m-[m
[31m-#parseMain.o:	parseMain.c  tiny.tab.h [m
[31m-#		gcc -c parseMain.c[m
[31m-[m
[31m-#tiny.tab.o:	tiny.y  symtab.h[m
[31m-#		bison tiny.y[m
[31m-#		gcc -c tiny.tab.c[m
[31m-[m
[31m-#testsymtab:	symtabMain.o symtab.o[m
[31m-#		gcc -o testsymtab symtabMain.o symtab.o[m
[31m-[m
[31m-#symtab.o:	symtab.c symtab.h[m
[31m-#		gcc -c symtab.c[m
[31m-[m
[31m-#symtabMain.o: 	symtabMain.c symtab.h[m
[31m-#		gcc -c symtabMain.c[m
[31m-# use del on Windows. use rm on Linux/Cygwin/Mac[m
[31m-#clean:		[m
[31m-#		rm *.o [m
[31m-[m
[31m-[m
[31m-[m
[1mdiff --git a/README.txt~ b/README.txt~[m
[1mdeleted file mode 100644[m
[1mindex 9a564f7..0000000[m
[1m--- a/README.txt~[m
[1m+++ /dev/null[m
[36m@@ -1,124 +0,0 @@[m
[31m-====================[m
[31m-Description of files[m
[31m-Project 4[m
[31m-By Christine Fossaceca[m
[31m-====================[m
[31m-Makefile	File for compiling/building program using make utility.[m
[31m-README.txt		This file.[m
[31m-symtab.c	The file holding all of the functions to generate and query the symbol table.[m
[31m-symtab.h 	Header file for symtab.c[m
[31m-symtab.o 	Class output file created by gcc compiler for symtab.c[m
[31m-parseMain.c	Template C file containing the main routine for testing the parser.[m
[31m-cminus.l	Template Flex input file for generating scanner[m
[31m-cminus.y      	Template Bison file to generate the header file for token values.[m
[31m-cminus.tab.c 	Autogenerated file for header file with token values[m
[31m-cminus.tab.h 	Autogenerated header file with token values[m
[31m-lex.yy.c     	Lexical analyzer autogenerated file called by main[m
[31m-lex.yy.o     	Class output file created by gcc compiler for lex.yy.c[m
[31m-parseMain.o   	Class output file created by gcc compiler for parseMain.c[m
[31m-parse         	actual parserinvoked by ./scan[m
[31m-gencode		code generator invoked by ./gencode[m
[31m-gencode.c	The file holding all of the code generation functions[m
[31m-gencodeMain.c	Parse file [m
[31m-gencodeMain.o	Class output file created by gcc compiler for gencodeMain.c[m
[31m-gencode.o	Class output file created by gcc compiler for gencode.c[m
[31m-genLabel.c	Given file to create labels[m
[31m-addtest.c	C file testing add functionality[m
[31m-addtest.j	Jasmin byte code file for addtest.c[m
[31m-arraytest2.c	Global vs local arraytest file test 2 [m
[31m-arraytest2.j	Jasmin byte code file for arraytest2.c[m
[31m-arraytest.c	Global vs local arraytest file [m
[31m-arraytest.j	Jasmin bytecode [m
[31m-concat.c	Given file to concatenate strings[m
[31m-D-Java.exe	Java disassmbler[m
[31m-Functions.c	File to test function declarations and calls[m
[31m-Functions.j	Jasmin Bytecode of Functions.c[m
[31m-functiontest.c  File to test function declarations and calls[m
[31m-functiontest.j 	Jasmin Bytecode of functiontest.j[m
[31m-globvartest.c   Testing global variables[m
[31m-globvartest.j	Jasmin bytecode for globvartest.j[m
[31m-HelloWorld.c	File to test the function of the print command[m
[31m-HelloWorld.j	Jasmin bytecode of print command[m
[31m-iftest.c	Testing of if statements[m
[31m-iftest.j	Jasmin bytecode of if statements[m
[31m-jasmin.jar	Jasmin jar file[m
[31m-Main.class	Main class file to be run in java[m
[31m-manyvariables.c	a test of many variables and arrays in c[m
[31m-manyvariables.j	Jasmin bytecode testing arrays and variables[m
[31m-relops1.c	a test of the relative operators[m
[31m-relops1.j	Jasmin bytecode for the first relops.c file[m
[31m-relops2.c	A second relative operators test[m
[31m-relops2.j	Jasmin bytecode for relops2.c[m
[31m-scan.c		Test of scanf functionality[m
[31m-scan.j		Jasmin bytecode for scanf[m
[31m-simptest2.c	simple program test file[m
[31m-simptest2.j	simple program output [m
[31m-simptest3.c	simple program test file[m
[31m-simptest3.j	simple program output [m
[31m-simptest.c      simple program test file[m
[31m-simptest.j      simple program output [m
[31m-SomeClass.c     example program from slides[m
[31m-SomeClass.j     example program output[m
[31m-subtest.c	testing subtraction and division[m
[31m-subtest.j 	output of subtraction and division[m
[31m-whiletest.c	testing a while loop[m
[31m-whiletest.j	output in bytecode of a while loop[m
[31m-arith.c		file testing arithmatic operations and identifiers[m
[31m-arith.j   	output of arith.c bytecode[m
[31m-bsort.c		bubble sort program [m
[31m-bsort.j   	output of bsort.c bytecode[m
[31m-bsorti.c	bubble sort program with scanning[m
[31m-bsorti.j   	output of bsort.c bytecode[m
[31m-arr1 - arr3.c	examples of global and local arrays[m
[31m-arr1 - arr3.j	examples of global and local array in bytecode[m
[31m-fact.c      	simple printf file[m
[31m-fact.j    	output of fact.c bytecode[m
[31m-func1 - func5.c	examples of different simple functions[m
[31m-func1 - func5.j function examples in bytecode[m
[31m-gcd.c       	greatest common denominator program[m
[31m-gcd.j     	output of gcd.c bytecode[m
[31m-gcdi.c      	Finding greatest common denominator with Euclid's method[m
[31m-gcdi.j		output of gcdi.c bytecode [m
[31m-if1.c		example of an if statement[m
[31m-if1.j		bytecode of an if statement[m
[31m-if2.c		example of an if statement[m
[31m-if1.j		bytecode of an if statement[m
[31m-loop.c		example of a while loop[m
[31m-loop.j		bytecode of a while loop[m
[31m-sq.c		a function to square a variable[m
[31m-sq.j		bytecode to square a variable[m
[31m-ssort.c     	simple sorting program[m
[31m-ssort.j   	output of ssort.c bytecode[m
[31m-ssorti.c     	simple sorting program with scanning[m
[31m-ssorti.j   	output of ssorti.c bytecode[m
[31m-sum.c   	more math operation testing[m
[31m-sum.j		output of sum.c bytecode[m
[31m-[m
[31m-==============[m
[31m-How to compile[m
[31m-==============[m
[31m-Do [m
[31m-[m
[31m-make gencode[m
[31m-[m
[31m-==========[m
[31m-How to run[m
[31m-========== [m
[31m-[m
[31m-By default, the generated parse(parse or parse.exe) reads from stdin and writes to[m
[31m-stdout. You can redirect these to read from or write out to a file. E.g,[m
[31m-[m
[31m-./gencode <test1.c >test1.j[m
[31m-[m
[31m-java -jar jasmin.jar test1.j[m
[31m-[m
[31m-java Main[m
[31m-[m
[31m-=====================[m
[31m-Known limitation/bugs[m
[31m-=====================[m
[31m-[m
[31m-None.  Works on all files, and fulfills all of the requirements.  All of the files listed here can be compiled. In addition, scanf works as well. [m
[31m-[m
[31m-[m
[31m-Printing only works with variables and arrays (not strings) as that is not supported in C-Minus[m
[1mdiff --git a/cminus.l~ b/cminus.l~[m
[1mdeleted file mode 100644[m
[1mindex a68b6f7..0000000[m
[1m--- a/cminus.l~[m
[1m+++ /dev/null[m
[36m@@ -1,128 +0,0 @@[m
[31m-/* [m
[31m-Christine Fossaceca[m
[31m-Project 2[m
[31m-[m
[31m-Name: cminus.l[m
[31m-[m
[31m-Do[m
[31m-[m
[31m-flex cminus.1[m
[31m-[m
[31m-gcc -c lex.yy.c [m
[31m-[m
[31m-to compile [m
[31m- */[m
[31m-%{[m
[31m-[m
[31m-#include "cminus.tab.h"[m
[31m-[m
[31m-int value;[m
[31m-int  row = 1;[m
[31m-int col = 1;[m
[31m-%}[m
[31m-[m
[31m-%option noyywrap[m
[31m-[m
[31m-digit                  [0-9][m
[31m-[m
[31m-letter                   [a-z]|[A-Z][m
[31m-[m
[31m-%%[m
[31m-[m
[31m-                                {col = col +yyleng;}                       /*Information from textbook, multiline comment rule*/      [m
[31m-"/*" 				{ char c; int done = 0;[m
[31m-			 	 do{[m
[31m-                                 /*incr row each new line*/[m
[31m-			   	 while ((c=input())!='*')[m
[31m-					{ if ( c == '\n')[m
[31m-						row++;}[m
[31m-				 while ((c=input())=='*'){}[m
[31m-					/* star w/0 slash gets incr*/[m
[31m-                                        if ( c == '\n')[m
[31m-						row++;[m
[31m-					if(c =='/'){[m
[31m-                                             done = 1;}[m
[31m-				   } while (done!=1);[m
[31m-				}[m
[31m-[m
[31m-"("                             {col = col + strlen(yytext);return LPAR;}[m
[31m-[m
[31m-")"                             {col = col + strlen(yytext);return RPAR;}[m
[31m-[m
[31m-";"                             {col = col + strlen(yytext);return SEMI;}[m
[31m-[m
[31m-"-"                             {col = col + strlen(yytext);return SUB;}[m
[31m-[m
[31m-"+"                             {col = col + strlen(yytext);return ADD;}[m
[31m-[m
[31m-\=\=                           {col = col + strlen(yytext);return EQUAL;} [m
[31m-[m
[31m-"="                            {col = col + strlen(yytext);return ASSIGN;}[m
[31m-[m
[31m-"&"                            {col = col + strlen(yytext);return AMP;}[m
[31m-[m
[31m-"else"                         {col = col + strlen(yytext);return ELSE;}[m
[31m-[m
[31m-"if"                           {col = col + strlen(yytext);return IF;}[m
[31m-[m
[31m-"int"                          {col = col + strlen(yytext);return INT;}[m
[31m-[m
[31m-"return"                       {col = col + strlen(yytext);return RET;}[m
[31m-[m
[31m-"void"                         {col = col + strlen(yytext);return VOID;}[m
[31m-[m
[31m-"while"                        {col = col + strlen(yytext);return WHILE;}[m
[31m-[m
[31m-"*"                            {col = col + strlen(yytext);return MULT;}[m
[31m-[m
[31m-"/"                            {col = col + strlen(yytext);return DIV;}[m
[31m-[m
[31m-"<"                            {col = col + strlen(yytext);return LESS;}[m
[31m-[m
[31m-"<="                           {col = col + strlen(yytext);return LESSEQ;}[m
[31m-[m
[31m-">"                            {col = col + strlen(yytext);return GREAT;}[m
[31m-[m
[31m-">="                           {col = col + strlen(yytext);return GREATEQ;}[m
[31m-[m
[31m-"!="                           {col = col + strlen(yytext);return NOTEQ;}[m
[31m-[m
[31m-","                            {col = col + strlen(yytext);return COMMA;}[m
[31m-[m
[31m-"["                            {col = col + strlen(yytext);return LBRACK;}[m
[31m-[m
[31m-"]"                            {col = col + strlen(yytext);return RBRACK;}[m
[31m-[m
[31m-"{"                            {col = col + strlen(yytext);return LCURLY;}[m
[31m-[m
[31m-"}"                            {col = col + strlen(yytext);return RCURLY;}[m
[31m-[m
[31m-"printf"                       {col = col + strlen(yytext);return PRINTF;}[m
[31m-[m
[31m-"\"%d\\n\""                    {col = col + strlen(yytext);return FSTRING;}[m
[31m-					/*note escape chars*/[m
[31m-[m
[31m-"\"%d\""                       {col = col + strlen(yytext);return DSTRING;}[m
[31m-[m
[31m-"scanf"                        {col = col + strlen(yytext);return SCANF;}[m
[31m-               [m
[31m-\/\/.+                            { } /* ignore // comments*/[m
[31m-[m
[31m-"\n"				{row++; col = 1;}[m
[31m-[m
[31m-{digit}+                 {col = col + strlen(yytext); value = yyval.intval = atoi(yytext); return NUM;}[m
[31m-[m
[31m-{letter}+                {col = col + strlen(yytext); yylval.strval = (char*)strdup(yytext);return ID;}[m
[31m-[m
[31m-\r                         {/* Nothing*/}[m
[31m-[m
[31m-[\t]                       {col = col + 3;}[m
[31m-[m
[31m-[ \t\r]+                      { col = col +yyleng; }[m
[31m- [m
[31m-   /* final rule to trap everything else */[m
[31m-.                               {return ERROR;}[m
[31m-[m
[31m-[m
[31m-[m
[31m-%%[m
[1mdiff --git a/cminus.y~ b/cminus.y~[m
[1mdeleted file mode 100644[m
[1mindex 8441be3..0000000[m
[1m--- a/cminus.y~[m
[1m+++ /dev/null[m
[36m@@ -1,557 +0,0 @@[m
[31m-/*[m
[31m-Christine Fossaceca[m
[31m-Project 4[m
[31m-[m
[31m-Gencode Added[m
[31m-[m
[31m-Name: cminus.y[m
[31m-[m
[31m-Bison file to generate the header file for token values.[m
[31m-[m
[31m-Do [m
[31m-[m
[31m-bison -d cminus.y [m
[31m-[m
[31m-to generate cminus.tab.h and then #include[m
[31m-this in the .l file. To generate the lexer, do[m
[31m-[m
[31m-flex cminus.l[m
[31m-gcc lex.yy.c  [m
[31m-[m
[31m-*/[m
[31m-%{[m
[31m-#include <stdio.h>[m
[31m-#include "symtab.h"[m
[31m-#include <stdlib.h>[m
[31m-#include <string.h>[m
[31m-[m
[31m-extern char * yytext;[m
[31m-extern int yylex();[m
[31m-extern int row; //count the rows[m
[31m-extern int col; //count the columns[m
[31m-void yyerror (char const *s);[m
[31m-char * concat( char * str1, char * str2);[m
[31m-int JVM = 0;[m
[31m-int location = 0;[m
[31m-int scope = 0;[m
[31m-int size = 0;[m
[31m-char * kind;[m
[31m-char * print;[m
[31m-int params= 0;[m
[31m-int type = 0;[m
[31m-int mainFlag;[m
[31m-int count=0;[m
[31m-int inserted;[m
[31m-int flag =0;[m
[31m-char * compare;[m
[31m-char * string;[m
[31m-char save[80];[m
[31m-char * lab1;[m
[31m-char* lab2;[m
[31m-char * lab3;[m
[31m-char *lab4;[m
[31m-int errFlag;[m
[31m-int refresh;[m
[31m-char * blank = " ";[m
[31m-int scopeChange = 0;[m
[31m-int callFlag = 0;[m
[31m-int oppFlag = 0;[m
[31m-int brackFlag= 0;[m
[31m-int scanCalled=0;[m
[31m-int relopsFlag = 0;[m
[31m-int declaredTwice =0;[m
[31m-char * parmName = "notarealname";//must initialize to something[m
[31m-%}[m
[31m-[m
[31m-%union[m
[31m-{ [m
[31m-	int intval;[m
[31m-	char * strval;[m
[31m-	[m
[31m-}[m
[31m-[m
[31m-%error-verbose[m
[31m-/*%expect 1 got rid of this */[m
[31m-[m
[31m-[m
[31m-/*tokens*/[m
[31m-%token WHILE INT RET VOID ELSE IF MULT DIV ADD SUB LESS LESSEQ GREAT GREATEQ[m
[31m-%token EQUAL NOTEQ ASSIGN SEMI COMMA LPAR RPAR LBRACK RBRACK LCURLY RCURLY[m
[31m-%token ERROR PRINTF FSTRING DSTRING SCANF AMP [m
[31m-[m
[31m-/*special tokens*/[m
[31m-%token <intval> NUM[m
[31m-%token <strval> ID[m
[31m-%% [m
[31m-[m
[31m-/*context-free grammar*/[m
[31m-[m
[31m-program		: 	{genBegin(); }declarationlist { {if (mainFlag!=1){printf("Semantic Error: No Main function at row = %d\tcol = %d.\n", row, col);}}genConstruct();if(count!= 0)[m
[31m-{printGlobArr(); genRet();} genEnd();}[m
[31m-		;[m
[31m-[m
[31m-declarationlist	:	declarationlist declaration[m
[31m-		|	declaration[m
[31m-		;[m
[31m-	[m
[31m-declaration	:	vardeclaration[m
[31m-		|	fundeclaration[m
[31m-		;[m
[31m-[m
[31m-vardeclaration	:	INT ID SEMI[m
[31m-				{[m
[31m-				[m
[31m-				if(st_lookup($2, "variable", INT, scope) ==-1){[m
[31m-					st_insert($2,location, JVM, scope, "variable", size, INT, params); [m
[31m-				if(scope == 0)[m
[31m-				{[m
[31m-				genVar(scope, $2, jvm_lookup($2, "variable",INT, scope));[m
[31m-				}[m
[31m-					[m
[31m-				JVM++; location++;scopeChange=0;}[m
[31m-					[m
[31m-				[m
[31m-				else if(st_lookup($2, "variable", INT, scope) ==-2)[m
[31m-				{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Can't have two variables %s of different  RETURN types. The return of %s is VOID\n", row, col, $2, $2);//this is a little redundant, already taken care of above, but needed to account for all outputs to lookup function[m
[31m-				}[m
[31m-				else if (st_lookup($2, "variable", INT, scope) ==-3)[m
[31m-				{printf("Semantic Error: row = %d\tcol = %d.Can't have two names %s of different types. %s is an array\n", row, col,$2, $2);}[m
[31m-				else if (st_lookup($2, "variable",INT, scope) ==-4) {if((scopeChange ==1)&&(strcmp(parmName, $<strval>2)!= 0)){st_insert($2,location, JVM, scope, "variable", size, INT, params); JVM++; location++;scopeChange = 0;changeTwice ($2);}[m
[31m-	[m
[31m-}[m
[31m-else {                         printf("Semantic Error: row = %d\tcol = %d. Can't redeclare name %s in current scope.\n", row, col, $2);}}[m
[31m-		|	VOID ID SEMI  [m
[31m-				{[m
[31m-				if(st_lookup($2, "variable", VOID, scope) ==-1){[m
[31m-				[m
[31m-					printf("Semantic Error: row = %d\tcol = %d. Can't have variable %s of type VOID\n",row, col, $2);[m
[31m-				}[m
[31m-				[m
[31m-				else if(st_lookup($2, "variable", VOID, scope) >=0)[m
[31m-				{[m
[31m-				[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Can't have two variables %s of different  RETURN types. Already exists with return INT\n", row, col, $2);//this is a little redundant, already taken care of above, but needed to account for all outputs to lookup function[m
[31m-				}[m
[31m-				else if (st_lookup($2, "variable", INT, scope) ==-3)[m
[31m-				{printf("Semantic Error: row = %d\tcol = %d.Can't have two names %s of different types. %s is a variable\n",row, col, $2, $2);}[m
[31m-				else if (st_lookup($2, "variable", returnType($2), scope) ==-4) {printf("Semantic Error: row = %d\tcol = %d. Can't redeclare variable in same scope\n",row, col);}[m
[31m-	else {printf("Semantic Error:row = %d\tcol = %d. Variable %s has already been declared\n",row, col,$2); [m
[31m-				}[m
[31m-}[m
[31m-		|       INT ID LBRACK NUM RBRACK SEMI[m
[31m-			[m
[31m-				{if (st_lookup($2, "array", INT, scope) ==-1) [m
[31m-					{	[m
[31m-				 [m
[31m-					st_insert($2,location, JVM, scope, "array", $4, INT, params); genArr(scope, $2, $4, jvm_lookup($2, "array",INT, scope));JVM++; location++;scopeChange = 0; if(scope ==0) {count = count + 1 ;}			[m
[31m-					[m
[31m-				}[m
[31m-				else if(st_lookup($2, "array", returnType($2),scope) ==-2)[m
[31m-				{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Can't have two arrays %s of different RETURN types. Already exists with return type VOID\n",row, col, $2);//this is a little redundant, already taken care of above, but needed to account for all outputs to lookup function[m
[31m-				}[m
[31m-				else if (st_lookup($2, "array", returnType($2), scope) ==-3){[m
[31m-				printf("Semantic Error: row = %d\tcol = %d.Can't have two names %s of different types.  %s is a variable\n",row, col, $2,$2);}[m
[31m-				else if (st_lookup($2, "array", returnType($2),scope) ==-4) {if(scopeChange ==1) {st_insert($2,location, JVM, scope, "variable", size, INT, params); JVM++; location++;scopeChange = 1;changeTwice($2);} else{printf("Semantic Error: row = %d\tcol = %d. Can't redeclare name %s in current scope.\n", row, col, $2);}}[m
[31m-				else[m
[31m-				{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Can't redeclare name %s in current scope.\n", row, col, $2);	[m
[31m-				}[m
[31m-			}[m
[31m-		[m
[31m-		|       VOID ID LBRACK NUM RBRACK SEMI[m
[31m-			[m
[31m-				{if (st_lookup($2, "array", VOID, scope) ==-1) [m
[31m-				{[m
[31m-				printf("Semantic Error:row = %d\tcol = %d. Can't have array %s of type VOID\n",row, col, $2);[m
[31m-				}[m
[31m-				else if(st_lookup($2, "array", VOID,scope) ==-2)[m
[31m-				{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Can't have two arrays %s of different RETURN types. The return type of %s is %d\n",row, col, $2, $2, returnType($2));[m
[31m-				}[m
[31m-				else if (st_lookup($2, "array", VOID, scope) ==-3)[m
[31m-				{printf("Semantic Error: row = %d\tcol = %d. Can't have two names %s of different types.  %s is a variable\n",row, col, $2,$2);}[m
[31m-				else if (st_lookup($2, "array", VOID,scope) ==-4) {printf("Semantic Error: row = %d\tcol = %d.Can't redeclare array in same scope\n",row,col);}[m
[31m-				else[m
[31m-				{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d.Array %s has already been declared\n",row, col, $2); [m
[31m-				}[m
[31m-			}[m
[31m-		;[m
[31m-[m
[31m-[m
[31m-fundeclaration	:	INT ID LPAR [m
[31m-			{ 	scanCalled = 0;parmName = $2;[m
[31m-				inserted = 0;[m
[31m-				if (mainFlag ==1)[m
[31m-				{printf("Semantic Error: row = %d\tcol = %d.Cannot insert function %s after main",row, col, $2);[m
[31m-				} [m
[31m-				else{  [m
[31m-					if(st_lookup($2, "function", INT, scope) ==-1) 						{		[m
[31m-						if(strcmp($<strval>2, "main") ==0) [m
[31m-							{[m
[31m-								printf("Semantic Error: row = %d\tcol = %d. Cannot assign main type int\n", row, col);[m
[31m-							}[m
[31m-					else {JVM = 0;}[m
[31m-					type = INT;[m
[31m-					if (strcmp($<strval>2, "main") !=0)[m
[31m-					{ params = 0; [m
[31m-					  st_insert($2,location, JVM, scope, "function", size, type, params); inserted = 1;[m
[31m-					} [m
[31m-					if(mainFlag==1)[m
[31m-					{ /*Don't do anything*/   }[m
[31m-					else{printf(";>> FUNCTION %s <<\n", $2);printf(".method static %s(",$2);location++; params = 0;/*reset the value of params*/ }[m
[31m-					}		        [m
[31m-					else if(st_lookup($2, "function", INT, scope) ==-2)					{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Can't have two functions %s of different RETURN types. Already exists as type VOID\n", row, col, $2);//this is a little redundant, already taken care of above, but needed to account for all outputs to lookup function[m
[31m-				}[m
[31m-				else if (st_lookup($2, "function", returnType($2), scope) ==-3){printf("Semantic Error: row = %d\tcol = %d. Can't have two names %s of different types.  %s is a function\n",row, col, $2,$2);}[m
[31m-		else if (st_lookup($2, "function", returnType($2),scope) ==-4){printf("Semantic Error: row = %d\tcol = %d. Can't redeclare function in same scope\n", row, col);}[m
[31m-[m
[31m-				else {[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Function %s already in scope\n",row, col, $2); }[m
[31m-			}[m
[31m-}[m
[31m-			parameters{if(mainFlag!=1){st_update($2, params);}} RPAR {if((inserted ==1)&& (mainFlag!=1))[m
[31m-					{[m
[31m-					printf(")");[m
[31m-					if(returnType($2) == INT)[m
[31m-					{printf("I\n"); }[m
[31m-					else{	printf("V\n");[m
[31m-					}[m
[31m-				 genFunc();					[m
[31m-					} }compoundstmt {  printf("ireturn\n");[m
[31m-  printf(".end method\n\n");}[m
[31m-[m
[31m-		|	VOID ID LPAR [m
[31m-			{ 	scanCalled = 0;  parmName=$2;inserted = 0;[m
[31m-				if (mainFlag ==1)[m
[31m-				{printf("Semantic Error: row = %d\tcol = %d. Cannot insert function %s after main\n", row, col, $2);[m
[31m-				} [m
[31m-				else{  [m
[31m-				if(st_lookup($2, "function", VOID, scope) ==-1) {		[m
[31m-					if(strcmp($<strval>2, "main") ==0) {[m
[31m-					[m
[31m-					mainFlag = 1;	JVM = 1;			[m
[31m-					}[m
[31m-					else {JVM = 0;}[m
[31m-					type = VOID;[m
[31m-					params = 0;[m
[31m-					st_insert($2,location, JVM, scope, "function", size, type, params); inserted = 1; if(mainFlag==1)[m
[31m-	{genMain();}else{printf(";>> FUNCTION %s <<\n", $2);printf(".method static %s(",$2);location++; params = 0;/*reset the value of params*/ }[m
[31m-					}			        [m
[31m-				else if(st_lookup($2, "function", VOID, scope) ==-2)[m
[31m-				{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Can't have two functions %s of different RETURN types. Already exists of type INT\n",row, col, $2);//this is a little redundant, already taken care of above, but needed to account for all outputs to lookup function[m
[31m-				}[m
[31m-				else if (st_lookup($2, "function", VOID, scope) ==-3)[m
[31m-				{printf("Semantic Error: row = %d\tcol = %d. Can't have two names %s of different types.  %s is a function\n", row, col, $2,$2);}[m
[31m-		else if (st_lookup($2, "function", VOID,scope) ==-4) {printf("Semantic Error: row = %d\tcol = %d.Can't redeclare function in same scope\n", row , col);}[m
[31m-[m
[31m-				else {[m
[31m-				printf("Semantic Error:row = %d\tcol = %d. Function %s already in scope\n",row, col, $2); 	[m
[31m-					}[m
[31m-			}[m
[31m-}[m
[31m-			parameters{if(mainFlag!=1){st_update($2, params);}} RPAR {if((inserted ==1)&& (mainFlag!=1))[m
[31m-					{[m
[31m-					printf(")");[m
[31m-					if(returnType($2) == INT)[m
[31m-					{printf("I\n"); }[m
[31m-					else{	printf("V\n");[m
[31m-					}[m
[31m-				 genFunc();					[m
[31m-					} /*genFunc();*/} compoundstmt {genRet();}[m
[31m-[m
[31m-		;[m
[31m-[m
[31m-[m
[31m-parameters          :	paramslist[m
[31m-		|	VOID [m
[31m-		;[m
[31m-[m
[31m-paramslist	:       paramslist COMMA param[m
[31m-		|	param[m
[31m-		;[m
[31m-[m
[31m-param		: 	INT ID[m
[31m-			{[m
[31m-			if (st_lookup($2, "variable", INT, scope) ==-1)                  {parmName=$2;[m
[31m-				params++;[m
[31m-				scope++; scopeChange = 1;[m
[31m-			st_insert($2,location, JVM, scope, "variable", size, INT, params);printf("I"); JVM++; location++; scope--; [m
[31m-[m
[31m-			}[m
[31m-			else if(st_lookup($2, "variable", returnType($2), scope) ==-2)				{[m
[31m-				printf(" Semantic Error: row = %d\tcol = %d. Variable %s was declared with a different RETURN type. The return type of %s is VOID\n",row, col, $2, $2);//this is a little redundant, already taken care of above, but needed to account for all outputs to lookup function[m
[31m-				}[m
[31m-				else if (st_lookup($2, "variable", returnType($2), scope)==-3)[m
[31m-				[m
[31m-				{printf("Semantic Error: row = %d\tcol = %d. Can't have two names %s of different types.  %s was already declared as a variable\n",row, col, $2,$2);}[m
[31m-		[m
[31m-					[m
[31m-			else {  printf("I"); [m
[31m-				params++;[m
[31m-				scope++;scopeChange = 1;[m
[31m-			st_insert($2,location, JVM, scope, "variable", size, INT, params); JVM++; location++; scope--;parmName=$2;changeTwice($2);[m
[31m-				}[m
[31m-		}[m
[31m-			[m
[31m-		[m
[31m-		|	VOID ID[m
[31m-			{[m
[31m-			if (st_lookup($2, "variable",VOID, scope) ==-1)                  	{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Can't have variable %s of type VOID\n",row, col, $2);	[m
[31m-			}[m
[31m-[m
[31m-			[m
[31m-			else if(st_lookup($2, "variable", VOID, scope) ==-2)			{	printf("Semantic Error: row = %d\tcol = %d. Variable %s was declared with a different RETURN type. The return type of %s is INT", row, col, $2, $2);//this is a little redundant, already taken care of above, but needed to account for all outputs to lookup function[m
[31m-				}[m
[31m-				else if (st_lookup($2, "variable", VOID, scope)==-3)[m
[31m-				{printf("Semantic Error: row = %d\tcol = %d. Can't have two names %s of different types.  %s was already declared as a variable\n",row, col, $2,$2);}		[m
[31m-			else {[m
[31m-				[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Param Variable %s already declared\n",row, col, $2); [m
[31m-				}[m
[31m-			[m
[31m-		}[m
[31m-[m
[31m-		|	INT ID LBRACK RBRACK[m
[31m-			{if (st_lookup($2, "array", INT, scope) ==-1) [m
[31m-			{[m
[31m-				parmName=$2;[m
[31m-				params++; scope++;scopeChange = 1;[m
[31m-				st_insert($2,location, JVM, scope, "array", size, INT, params); printf("[I");JVM++; location++; scope--;[m
[31m-		        }[m
[31m-			else if(st_lookup($2, "array", returnType($2),scope) ==-2)[m
[31m-				{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Array %s was declared with a different RETURN type. Already delcared type VOID\n", row, col, $2);//this is a little redundant, already taken care of above, but needed to account for all outputs to lookup function[m
[31m-				}[m
[31m-				else if (st_lookup($2, "array", returnType($2),scope) ==-3)[m
[31m-				{printf("Semantic Error: row = %d\tcol = %d. Can't have two names %s of different types.  %s is was declared as an array\n", row, col, $2,$2);}		[m
[31m-			[m
[31m-			else {   printf("[I");[m
[31m-				 params++;[m
[31m-				 scope++;scopeChange = 1; [m
[31m-				st_insert($2,location, JVM, scope, "array", size, INT, params); JVM++; location++; scope--;changeTwice($2);[m
[31m-			parmName=$2;}[m
[31m-			[m
[31m-		}[m
[31m-[m
[31m-		|	VOID ID LBRACK RBRACK[m
[31m-			{if (st_lookup($2, "array", VOID, scope) ==-1) [m
[31m-			{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Can't have array %s of type VOID\n",row, col,$2);						}[m
[31m-			[m
[31m-			else if(st_lookup($2, "array", VOID,scope) ==-2)[m
[31m-				{[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Array %s was declared with a different RETURN type. Already returns type INT\n", row, col, $2);//this is a little redundant, already taken care of above, but needed to account for all outputs to lookup function[m
[31m-				}[m
[31m-				else if (st_lookup($2, "array", VOID,scope) ==-3)[m
[31m-				{printf("Can't have two names %s of different types.  %s is was declared as an array\n", $2,$2);}	[m
[31m-			[m
[31m-[m
[31m-			else {[m
[31m-				printf("Semantic Error: row = %d\tcol = %d. Param Array %s already declared\n",row, col,$2); [m
[31m-			}[m
[31m-		}		[m
[31m-		;		[m
[31m-		[m
[31m-[m
[31m-compoundstmt	: 	LCURLY{scope++;scopeChange = 1;} localdeclarations stmtlist RCURLY {scope--;scopeChange = 1;}[m
[31m-		;[m
[31m-[m
[31m-localdeclarations :	localdeclarations vardeclaration[m
[31m-		|	/* empty */[m
[31m-		;	[m
[31m-[m
[31m-stmtlist	:	stmtlist stmt[m
[31m-		|	/* empty */[m
[31m-		;[m
[31m-[m
[31m-stmt		:	assignstmt[m
[31m-		|	compoundstmt[m
[31m-		|	selectionstmt[m
[31m-		|	iterationstmt[m
[31m-		|	returnstmt[m
[31m-		|	printstmt[m
[31m-		|	scanstmt[m
[31m-		|	callstmt[m
[31m-		|	SEMI[m
[31m-		;[m
[31m-[m
[31m-callstmt	: 	call SEMI[m
[31m-		;[m
[31m-[m
[31m-/*selectionstmt	:	IF LPAR expression RPAR	stmt[m
[31m-		|	IF LPAR	expression RPAR stmt ELSE stmt[m
[31m-		;*/[m
[31m-[m
[31m-selectionstmt	:	IF LPAR{$<strval>$ = genLabel();}{$<strval>$ = genLabel();} expression RPAR {if(relopsFlag ==1){printf("%s\n", $<strval>3);}else{printf("ifeq %s\n", $<strval>3);}relopsFlag = 0;} stmt {printf("goto %s\n",$<strval>4); }ELSE{printf("%s:\n", $<strval>3);} stmt{printf("%s:\n", $<strval>4);}[m
[31m-		;[m
[31m-[m
[31m-iterationstmt	:	WHILE {$<strval>$ = genLabel();} {$<strval>$ = genLabel();} LPAR {printf("%s:\n",$<strval>2);} expression {if(relopsFlag ==1){printf("%s\n",$<strval>3);}else{printf("ldc 0\nif_icmple %s\n", $<strval>3);}} RPAR{relopsFlag = 0;} stmt {printf("goto %s\n",$<strval>2); printf("%s:\n", $<strval>3);}[m
[31m-		;[m
[31m-[m
[31m-returnstmt	:	RET SEMI[m
[31m-		|	RET expression SEMI[m
[31m-		;[m
[31m-[m
[31m-printstmt	:	PRINTF {genBeginPrint();} LPAR FSTRING COMMA expression RPAR SEMI {genEndPrint();} [m
[31m-		;[m
[31m-[m
[31m-scanstmt	: 	SCANF  LPAR DSTRING COMMA AMP ID RPAR SEMI[m
[31m-				{if (st_lookup($6, "variable", INT,scope) ==-1)[m
[31m-	 			{[m
[31m-				printf("Semantic Error:row = %d\tcol = %d.  Scan Variable %s not previously declared\n",row, col, $6);[m
[31m-				} [m
[31m-else if(st_lookup($6, "variable", INT,scope) ==-2)[m
[31m-				{[m
[31m-				//this probably won't happen but[m
[31m-			printf("Semantic Error: row = %d\tcol = %d. Variable was declared of type VOID. Abort Operation.\n",row, col);[m
[31m-				}[m
[31m-				else if (st_lookup($6, "variable", INT,scope) ==-3)[m
[31m-				//this won't happen either[m
[31m-{printf("Semantic Error: row = %d\tcol = %d. Can't have two names %s of different types.  %s was already declared as an array or function\n", row, col, $6,$6);}[m
[31m-				else{[m
[31m-				/*It worked*/if(scanCalled ==0){printf("new java/util/Scanner\ndup\ngetstatic java/lang/System/in Ljava/io/InputStream;\ninvokenonvirtual java/util/Scanner/<init>(Ljava/io/InputStream;)V\nastore 1\n");}scanNow(1);scanCalled =1;;if(returnScope($6) ==0)[m
[31m-					{printf("putstatic Main/%s I\n", $6);}[m
[31m-					else{[m
[31m-					printf("istore %d\n",jvm_lookup($6, "variable",INT, scope));}[m
[31m-				}				[m
[31m-				}[m
[31m-[m
[31m-		;[m
[31m-[m
[31m-assignstmt	:	ID {[m
[31m-			if (st_lookup($1, "variable", INT, scope) ==-1) {[m
[31m-				printf("Semantic Error:row = %d\tcol = %d. Exp Variable %s not previously declared\n",row, col, $1);  [m
[31m-				}[m
[31m-				else {/*genLoadVar(scope,jvm_lookup($1, "variable",INT, scope), $1);*/}}[m
[31m-			ASSIGN expression SEMI[m
[31m-			{[m
[31m-			if (st_lookup($1, "variable", INT,scope) ==-1) {[m
[31m-				printf("Semantic Error:row = %d\tcol = %d. Exp Variable %s not previously declared\n",row, col, $1); [m
[31m-				} [m
[31m-			else if(st_lookup($1, "variable", INT,scope) ==-2)[m
[31m-			 {printf("Semantic Error: row = %d\tcol = %d. Mismatched return type\n", row, col);}[m
[31m-[m
[31m-			else if (st_lookup($1, "variable", INT,scope) ==-3) [m
[31m-			{printf("Semantic Error: row = %d\tcol = %d. Mismatched type \n", row, col);}[m
[31m-                           else {if(returnScope($1) ==0)[m
[31m-					{printf("putstatic Main/%s I\n", $1);}[m
[31m-					else{[m
[31m-					printf("istore %d\n",jvm_lookup($1, "variable",INT, scope));}}[m
[31m-}[m
[31m-		|	ID {if (st_lookup($1, "array", INT, scope) ==-1) {[m
[31m-	printf("Semantic Error: row = %d\tcol = %d.Exp Array %s not previously declared\n",row, col, $1); }else {genLoadArr(returnScope($1),jvm_lookup($1, "array",INT, returnScope($1)), $1);}}LBRACK expression RBRACK ASSIGN expression SEMI[m
[31m-		{if (st_lookup($1, "array", INT,scope) ==-1) {[m
[31m-	printf("Semantic Error: row = %d\tcol = %d.Exp Array %s not previously declared\n",row, col, $1); }  else if (st_lookup($1, "array", INT,scope) ==-2) {printf("Semantic Error: row = %d\tcol = %d.Mismatched return type\n", row,col);}else if (st_lookup($1, "array", INT,scope) ==-3) {printf("Semantic Error:row = %d\tcol = %d. Mismatched type \n",row, col);}[m
[31m-			else { [m
[31m-					printf("iastore\n");[m
[31m-					}[m
[31m-}[m
[31m-		;[m
[31m-[m
[31m-expression	:	addexpression relop addexpression {$<intval>$ = $<intval>3;  printf("%s", $<strval>2);}[m
[31m-		|	addexpression {$<intval>$ = $<intval>1;}[m
[31m-		;[m
[31m-[m
[31m-relop		:       LESSEQ  {$<strval>$ = "if_icmpgt ";relopsFlag = 1;}[m
[31m-		|	LESS    {$<strval>$ = "if_icmpge ";relopsFlag = 1;}[m
[31m-		|	GREAT   {$<strval>$ = "if_icmple ";relopsFlag = 1;}[m
[31m-		|	GREATEQ {$<strval>$ = "if_icmplt ";relopsFlag = 1;}[m
[31m-		|	NOTEQ   {$<strval>$ = "if_icmpeq ";relopsFlag = 1;}[m
[31m-		|	EQUAL   {$<strval>$ = "if_icmpne ";relopsFlag = 1;}[m
[31m-		;[m
[31m-[m
[31m-addexpression	:	addexpression addop term{$<intval>$ = $<intval>3;printf("%s\n", $<strval>2);}/*{if($<intval>2 == ADD){$<intval>$ = returnType($2) + $<intval>3; genCodeAdd();} else{$<intval>$ = returnType($2) - $<intval>3; genCodeSub();}}*/[m
[31m-		|	term {$<intval>$ = $<intval>1; }[m
[31m-		;[m
[31m-[m
[31m-addop		:	ADD {oppFlag = 1;$<strval>$ = "iadd"; }[m
[31m-		|	SUB {oppFlag = 1;$<strval>$ = "isub"; }[m
[31m-		;[m
[31m-[m
[31m-term		: 	term mulop factor {$<intval>$ = $<intval>3;printf("%s\n", $<strval>2);}/*{if($<strval>2 == MULT){$<intval>$ = returnType($2) * $<intval>3; genCodeMul();} else{$<strval>$ = returnType($2) / $<intval>3; genCodeDiv();}}*/[m
[31m-		|	factor {$<intval>$ = $<intval>1; }[m
[31m-		;[m
[31m-[m
[31m-mulop		:	MULT {oppFlag = 1;$<strval>$ = "imul"; }[m
[31m-		|	DIV  {oppFlag = 1;$<strval>$ = "idiv"; };[m
[31m-		;[m
[31m-[m
[31m-factor		:	LPAR expression	RPAR[m
[31m-		|	call[m
[31m-		|	NUM{genLoadConst($1);if ((callFlag ==1)&&(brackFlag==0) ){  if ((flag == 0)){strcpy(save, print);flag = 1;}[m
[31m-			else{}}}[m
[31m-		|	ID LBRACK {brackFlag = 1;if (st_lookup($1, "array", INT, scope) ==-1) {[m
[31m-	printf("Semantic Error: row = %d\tcol = %d.Factor Array %s not previously declared\n",row, col, $1); [m
[31m-				}else {print = "[I";genLoadArr(returnScope($1),jvm_lookup($1, "array",INT, returnScope($1)), $1); }}expression RBRACK {brackFlag = 0;printf("iaload\n");}[m
[31m-		[m
[31m-		|	ID[m
[31m-			{  if (nameUsed($1) ==-1) {[m
[31m-			printf("Semantic Factor Error:  row = %d\tcol = %d. %s not previously declared \n",row, col, $1);[m
[31m-			} [m
[31m-                     [m
[31m-			else{ [m
[31m-                   	     string = returnKind($1);[m
[31m-			     if(strcmp(string, "variable") ==0)[m
[31m-				{[m
[31m-				print = "I"; [m
[31m-				if ((mainFlag !=0)||(returnTwice($1)==0)){genLoadVar(returnScope($1), jvm_lookup($1, "variable", INT, returnScope($1)),$1);} [m
[31m-				else {genLoadVar( scope, jvm_lookup($1, "variable", INT, returnScope($1)),$1);}}[m
[31m-			      else[m
[31m-			      {   [m
[31m-				print = "[I";[m
[31m-				genLoadArr(returnScope($1), jvm_lookup($1, "variable", INT, returnScope($1)),$1);[m
[31m-                              }  [m
[31m-		        if ((flag == 0) && (oppFlag ==0)){strcpy(save, print);flag = 1;}[m
[31m-			else{if(oppFlag ==0){strcat(save, print);}}[m
[31m-	  	}}	[m
[31m-		;[m
[31m-[m
[31m-call		: ID {callFlag=1;flag=0;oppFlag = 0;for(refresh = 0; refresh < 80;refresh++)[m
[31m-				{strcpy(save, blank); }[m
[31m-				} LPAR args[m
[31m-		{if (st_lookup($1, "function", type, scope) ==-1) [m
[31m-	    		{[m
[31m-			printf("Semantic Error: Function %s not previously declared\n",$1); }		[m
[31m-		/*else if(returnType($1) !=type){[m
[31m-			if(returnType($1)==261){compare = "VOID";} else {compare = "INT"; }[m
[31m-			printf("Semantic Error:  Function %s is already declared of type %s ", $1, compare );[m
[31m-	}      */else if(returnKind($1)!="function"){printf("Semantic Error: row = %d\tcol = %d. Function %s not previously declared\n",row, col, $1); }else{printf("invokestatic Main/%s(",$1);[m
[31m-	if(flag ==1){printf("%s", save);}}}  RPAR  [m
[31m-[m
[31m-		{scopeChange=1;if(returnType($1)==INT){printf(")I\n");} else{printf(")V\n");}callFlag=0;}[m
[31m-		;[m
[31m-[m
[31m-[m
[31m-args		:	arglist  {$<strval>$ = $<strval>1; }[m
[31m-		|	/* empty */[m
[31m-		;[m
[31m-[m
[31m-arglist		:	arglist COMMA expression   {$<strval>$ = concat(concat($<strval>1, ","),$<strval>1); }[m
[31m-		|	expression { oppFlag = 0;$<strval>$ = $<strval>1; }[m
[31m-		;		[m
[31m-[m
[31m-%%[m
[31m-void yyerror (char const *s)  /* Called by yyparse on error */[m
[31m-{[m
[31m-  printf("Error: syntax error at row = %d\tcol = %d. Got: %s\t\n", row, col,yytext);[m
[31m-  printf ("%s\n", s);[m
[31m-}[m
[31m-[m
[31m-char * concat( char * str1, char * str2) {[m
[31m-[m
[31m- char *str3;[m
[31m- str3 = (char *)calloc(strlen(str1) + strlen(str2) + 1,[m
[31m- sizeof(char));[m
[31m- strcpy(str3, str1);[m
[31m- strcat(str3, str2);[m
[31m-[m
[31m- return str3;[m
[31m-}[m
[31m-[m
[31m-[m
[1mdiff --git a/parseMain.c~ b/parseMain.c~[m
[1mdeleted file mode 100644[m
[1mindex 75be44a..0000000[m
[1m--- a/parseMain.c~[m
[1m+++ /dev/null[m
[36m@@ -1,10 +0,0 @@[m
[31m-#include "symtab.h"[m
[31m-[m
[31m-extern int yyparse();[m
[31m-[m
[31m-void main () {[m
[31m-  [m
[31m-  //int result = yyparse();[m
[31m-  printSymTab();[m
[31m-[m
[31m-} [m
[1mdiff --git a/symtab.c~ b/symtab.c~[m
[1mdeleted file mode 100644[m
[1mindex d4ae24c..0000000[m
[1m--- a/symtab.c~[m
[1m+++ /dev/null[m
[36m@@ -1,287 +0,0 @@[m
[31m-/****************************************************/[m
[31m-/* File: symtab.c                                   */[m
[31m-/* Symbol table implementation for the TINY compiler*/[m
[31m-/* (allows only one symbol table)                   */[m
[31m-/* Symbol table is implemented as a chained         */[m
[31m-/* hash table                                       */[m
[31m-/* Compiler Construction: Principles and Practice   */[m
[31m-/* Kenneth C. Louden                                */[m
[31m-/****************************************************/[m
[31m-[m
[31m-#include <stdio.h>[m
[31m-#include <stdlib.h>[m
[31m-#include <string.h>[m
[31m-#include "symtab.h"[m
[31m-[m
[31m-/* SIZE is the size of the hash table */[m
[31m-#define SIZE 211[m
[31m-[m
[31m-/* SHIFT is the power of two used as multiplier[m
[31m-   in hash function  */[m
[31m-#define SHIFT 4[m
[31m-[m
[31m-extern int scope;[m
[31m-extern int mainFlag;[m
[31m-/* the hash function */[m
[31m-static int hash ( char * key )[m
[31m-{ int temp = 0;[m
[31m-  int i = 0;[m
[31m-  while (key[i] != '\0')[m
[31m-  { temp = ((temp << SHIFT) + key[i]) % SIZE;[m
[31m-    ++i;[m
[31m-  }[m
[31m-  return temp;[m
[31m-}[m
[31m-[m
[31m-/* the list of line numbers of the source [m
[31m- * code in which a variable is referenced[m
[31m- */[m
[31m-/*[m
[31m-typedef struct LineListRec[m
[31m-   { int lineno;[m
[31m-     struct LineListRec * next;[m
[31m-   } * LineList;[m
[31m-*/[m
[31m-/* The record in the bucket lists for[m
[31m- * each variable, including name, [m
[31m- * assigned memory location, and[m
[31m- * the list of line numbers in which[m
[31m- * it appears in the source code[m
[31m- */[m
[31m-typedef struct BucketListRec[m
[31m-   { char * name;[m
[31m-    // LineList lines;[m
[31m-     int memloc ; /* memory location for variable */[m
[31m-     int type;//INT or VOID[m
[31m-     int JVM;     /* This is only for local variables*/[m
[31m-     int scope;  //Nesting level[m
[31m-     char * kind;//variable, function, or array[m
[31m-     int size; //arrays only[m
[31m-     int params;[m
[31m-     int flag;[m
[31m-     int twice; //if has been declared more than once[m
[31m-     struct BucketListRec * next;[m
[31m-   } * BucketList;[m
[31m-[m
[31m-/* the hash table */[m
[31m-static BucketList hashTable[SIZE];[m
[31m-[m
[31m-/* Procedure st_insert inserts line numbers and[m
[31m- * memory locations into the symbol table[m
[31m- * loc = memory location is inserted only the[m
[31m- * first time, otherwise ignored[m
[31m- */[m
[31m-void st_insert( char * name, int loc, int JVM , int scope, char *kind, int size, int type, int params)[m
[31m-{ int h = hash(name);[m
[31m-  BucketList l =  hashTable[h];[m
[31m-  while ((l != NULL) && (strcmp(name,l->name) != 0))[m
[31m-    l = l->next;[m
[31m-  if (l == NULL) /* variable not yet in table */[m
[31m-  { l = (BucketList) malloc(sizeof(struct BucketListRec));[m
[31m-    l->name = name;[m
[31m-    //l->lines = (LineList) malloc(sizeof(struct LineListRec));[m
[31m-    //l->lines->lineno = lineno;[m
[31m-    l->memloc = loc;[m
[31m-    l->scope = scope;[m
[31m-    l->kind = kind;[m
[31m-    l-> size = size;[m
[31m-    l->type = type;[m
[31m-    l->params = params;[m
[31m-    l-> JVM = JVM;[m
[31m-    l->twice = 0;[m
[31m-    //l->lines->next = NULL;[m
[31m-    l->next = hashTable[h];[m
[31m-    hashTable[h] = l; }[m
[31m-  else /* found in table, so just add line number */[m
[31m-  { //LineList t = l->lines;[m
[31m-    //while (t->next != NULL) t = t->next;[m
[31m-   // t->next = (LineList) malloc(sizeof(struct LineListRec));[m
[31m-    //t->next->lineno = lineno;[m
[31m-    //t->next->next = NULL;[m
[31m-  }[m
[31m-} /* st_insert */[m
[31m-[m
[31m-/* Function st_lookup returns the memory [m
[31m- * location of a variable or -1 if not found[m
[31m- */[m
[31m-int st_lookup ( char * name,char *kind, int type, int scope )[m
[31m-{ int h = hash(name);[m
[31m-  BucketList l =  hashTable[h];[m
[31m-  while ((l != NULL) && (strcmp(name,l->name) != 0))[m
[31m-    {l = l->next;[m
[31m-    }[m
[31m-  if (l == NULL) return -1;//doesnt exist, go ahead[m
[31m-  else if (l->type != type)return -2;//wrong INT/VOIF[m
[31m-  else if (l->kind != kind)return -3;//wrong variable/array/funct[m
[31m-  else if (l->scope ==scope) return -4;//wrong scope[m
[31m-  else return l->memloc;[m
[31m-}[m
[31m-[m
[31m-int jvm_lookup(char * name,char *kind, int type, int scope )[m
[31m-{ int h = hash(name);[m
[31m-  BucketList l = hashTable[h];[m
[31m-  while((l!= NULL) && (strcmp(name, l->name)!=0))[m
[31m-	{[m
[31m-	l = l->next;[m
[31m-	}[m
[31m-  if (l == NULL) return -1;//doesnt exist, go ahead[m
[31m-  else if(l->scope != 0) return l->JVM;[m
[31m-  else return 0;[m
[31m-}[m
[31m-[m
[31m-void returnParams(char*name)[m
[31m-{ int h = hash(name);[m
[31m-  printf("******\n%s\n******\n",name);//function name[m
[31m-  int scope;[m
[31m-  BucketList l =  hashTable[h];[m
[31m-  while ((l != NULL) && (strcmp(name,l->name) != 0))[m
[31m-    {l = l->next;[m
[31m-    }[m
[31m-  scope = (l->scope) +1;printf("******\n%d\n******\n",scope);//scope[m
[31m-  l->next;[m
[31m-  printf("******\n%s\n******\n",name);//function name[m
[31m-  while ((l != NULL) && (l->scope == scope) )[m
[31m-      printf("******\n%d\n******\n",scope);//scope	[m
[31m-      {if (l->kind == "variable")[m
[31m-	   {printf("I");[m
[31m-	    } [m
[31m-	    else{[m
[31m-		printf("[I");[m
[31m-		}     [m
[31m-      	l->next;[m
[31m-        printf("******\n%s\n******\n",name);//function name[m
[31m-       }[m
[31m-    [m
[31m-}[m
[31m-/* Procedure printSymTab prints a formatted [m
[31m- * listing of the symbol table contents [m
[31m- * to the listing file[m
[31m- */[m
[31m-void printSymTab()[m
[31m-{ int i;[m
[31m-  printf("Symbol Table \n");[m
[31m-  printf("-------------------------------\n");[m
[31m-  for (i=0;i<SIZE;++i)[m
[31m-  { if (hashTable[i] != NULL)[m
[31m-    { BucketList l = hashTable[i];[m
[31m-      while (l != NULL)[m
[31m-      { [m
[31m-        printf("kind: %-14s", l->kind);	[m
[31m-	printf("name: %-14s ",l->name);[m
[31m-	printf("scope: %-14d", l->scope);[m
[31m-	printf("type: %-14d", l->type);[m
[31m-	if((strcmp(l->kind,"array") == 0) && (l->size !=0))[m
[31m-	{	[m
[31m-		printf("size: %-14d", l->size);[m
[31m-	}[m
[31m-	if(strcmp(l->kind,"function") ==0)[m
[31m-	{[m
[31m-		printf("params: %-14d", l->params);[m
[31m-	}[m
[31m-	if(l->scope!= 0)[m
[31m-	{[m
[31m-		printf("JVM: %-14d", l->JVM);[m
[31m-	}[m
[31m-      //  printf("JVM #: %-8d  ",l->JVM);[m
[31m-       [m
[31m-	printf("\n");[m
[31m-        l = l->next;[m
[31m-      }[m
[31m-    }[m
[31m-  }[m
[31m-} /* printSymTab */[m
[31m-[m
[31m-[m
[31m-void printGlobArr(){[m
[31m-	int i;[m
[31m-	printf(".method static <clinit>()V\n");[m
[31m-	printf(".limit stack 1\n");[m
[31m-	printf(".limit locals 0\n");[m
[31m-	[m
[31m-  	for (i=0;i<SIZE;i++)[m
[31m-  	{ if (hashTable[i] != NULL)[m
[31m-    		{ BucketList l = hashTable[i];[m
[31m-      		while (l != NULL)[m
[31m-      		{ [m
[31m-			if((l->scope== 0) && (strcmp(l->kind,"array") == 0))[m
[31m-			{[m
[31m-				printf("ldc %d\n",l->size);[m
[31m-				printf("newarray int\n");[m
[31m-       				printf("putstatic Main/%s [I\n", l->name);[m
[31m-			}[m
[31m-		l = l->next;[m
[31m-  		}      [m
[31m-  		}[m
[31m-	}[m
[31m-	[m
[31m-} /* print all global arrays */[m
[31m-[m
[31m-int returnType(char*name)[m
[31m-{ int h = hash(name);[m
[31m-  BucketList l =  hashTable[h];[m
[31m-  while ((l != NULL) && (strcmp(name,l->name) != 0))[m
[31m-    {l = l->next;[m
[31m-    }[m
[31m-  if (l == NULL) return -1;//doesnt exist, go ahead[m
[31m-  else return l->type;[m
[31m-}[m
[31m-[m
[31m-int returnScope(char*name)[m
[31m-{ int h = hash(name);[m
[31m-  BucketList l =  hashTable[h];[m
[31m-  while ((l != NULL) && (strcmp(name,l->name) != 0))[m
[31m-    {l = l->next;[m
[31m-    }[m
[31m-  if (l == NULL) return -1;//doesnt exist, go ahead[m
[31m-  else return l->scope;[m
[31m-}[m
[31m-[m
[31m-int returnTwice(char*name)[m
[31m-{ int h = hash(name);[m
[31m-  BucketList l =  hashTable[h];[m
[31m-  while ((l != NULL) && (strcmp(name,l->name) != 0))[m
[31m-    {l = l->next;[m
[31m-    }[m
[31m-  if (l == NULL) return -1;//doesnt exist, go ahead[m
[31m-  else return l->twice;[m
[31m-}[m
[31m-[m
[31m-void changeTwice(char*name)[m
[31m-{ int h = hash(name);[m
[31m-  BucketList l =  hashTable[h];[m
[31m-  while ((l != NULL) && (strcmp(name,l->name) != 0))[m
[31m-    {l = l->next;[m
[31m-    }[m
[31m-  if (l != NULL) ;//doesnt exist, go ahead[m
[31m-  {l->twice = 1;}[m
[31m-}[m
[31m-[m
[31m-char * returnKind(char*name)[m
[31m-{ int h = hash(name);[m
[31m-  BucketList l =  hashTable[h];[m
[31m-  while ((l != NULL) && (strcmp(name,l->name) != 0))[m
[31m-    {l = l->next;[m
[31m-    }[m
[31m-  if (l != NULL)//doesnt exist, go ahead[m
[31m-  return l->kind;[m
[31m-}[m
[31m-[m
[31m-void st_update( char * name, int params)[m
[31m-{ int h = hash(name);[m
[31m-  BucketList l =  hashTable[h];[m
[31m-  while ((l != NULL) && (strcmp(name,l->name) != 0))[m
[31m-    {l = l->next;[m
[31m-    }[m
[31m-  if (l != NULL) ;//name doesnt exist, go ahead[m
[31m-   {l->params = params;}[m
[31m-}[m
[31m-[m
[31m-int nameUsed( char * name )[m
[31m-{ int h = hash(name);[m
[31m-  BucketList l =  hashTable[h];[m
[31m-  while ((l != NULL) && (strcmp(name,l->name) != 0))[m
[31m-    {l = l->next;[m
[31m-    }[m
[31m-  if (l == NULL) return 0;//name doesnt exist, go ahead[m
[31m-  else return 1;[m
[31m-}[m
[1mdiff --git a/symtab.h~ b/symtab.h~[m
[1mdeleted file mode 100644[m
[1mindex 0bc6c76..0000000[m
[1m--- a/symtab.h~[m
[1m+++ /dev/null[m
[36m@@ -1,44 +0,0 @@[m
[31m-/****************************************************/[m
[31m-/* File: symtab.h                                   */[m
[31m-/* Symbol table interface for the TINY compiler     */[m
[31m-/* (allows only one symbol table)                   */[m
[31m-/* Compiler Construction: Principles and Practice   */[m
[31m-/* Kenneth C. Louden                                */[m
[31m-/****************************************************/[m
[31m-#include <stdio.h>[m
[31m-#include <stdlib.h>[m
[31m-#ifndef _SYMTAB_H_[m
[31m-#define _SYMTAB_H_[m
[31m-[m
[31m-/* Procedure st_insert inserts line numbers and[m
[31m- * memory locations into the symbol table[m
[31m- * loc = memory location is inserted only the[m
[31m- * first time, otherwise ignored[m
[31m- */[m
[31m-void st_insert( char * name, int loc, int JVM, int scope, char* kind, int size, int type, int params);[m
[31m-[m
[31m-/* Function st_lookup returns the memory [m
[31m- * location of a variable or -1 if not found[m
[31m- */[m
[31m-int st_lookup ( char * name, char *kind, int type, int scope );[m
[31m-int jvm_lookup ( char * name, char *kind, int type, int scope );[m
[31m-/* Procedure printSymTab prints a formatted [m
[31m- * listing of the symbol table contents [m
[31m- * to the listing file[m
[31m- */[m
[31m-void printSymTab();[m
[31m-[m
[31m-void printGlobArr();[m
[31m-[m
[31m-int returnType(char * name);[m
[31m-[m
[31m-int returnScope(char *name);[m
[31m-[m
[31m-char * returnKind(char *name);[m
[31m-[m
[31m-void returnParams(char *name);[m
[31m-[m
[31m-void st_update( char * name, int params);[m
[31m-[m
[31m-int nameUsed( char * name );[m
[31m-#endif[m
